
=encoding utf8

=head1 TITLE

Synopsis 16: I/O

=head1 VERSION

    Created: 12 Sep 2006

    Last Modified: 11 Jan 2015
    Version: 29

Many of these functions will work as in Perl 5, except we're trying to
rationalize everything into roles.  For now you can assume most of the
important functions will automatically be in the C<CORE::> namespace.
However, with IO operations in particular, many of them are really very
basic global functions (terms) which take or generate a handle.  These
functions can be accessed using a method interface as well.

=head1 Overridable IO handles

In Perl 6, there are the I<standard> IO handles, and any number of overriding
inner filehandles for the same symbol.

The I<standard> handles are our old familiar friends (with familiar, but
slightly different names).  Standard input is C<$*IN>, standard output is
C<$*OUT>, and standard error is C<$*ERR>.  In Perl 6 these symbols represent
more of a concept than a given filehandle, since the meaning is contextually
determined.  The process's version of these handles live in the C<PROCESS::>
namespace, which is more global than the per-interpreter C<GLOBAL::>
namespace.

When no explicit filehandle is used, the standard IO operators are
defined in terms of the dynamic variables.  So the C<say> function
prints to C<$*OUT>, while C<note> prints to C<$*ERR>.  The C<lines()>
term inputs from C<$*ARGFILES> which defaults to C<$*IN> in the absence of any
filenames.  So any given dynamic scope (interpreter,
thread, function or method call) may redefine the current meaning of
any of those filehandles within the dynamic scope of itself and of
its called routines.

So to put it another way, when you write something like

  say "Howdy, world!"

the C<say> function looks for the current meaning of C<$*OUT>, and
takes the closest definition it can find in its callers.  If none
of the callers have overridden the definition, it looks in the
interpreter's C<GLOBAL> namespace.  If the interpreter hasn't overridden
the meaning, it takes the meaning from the C<PROCESS> namespace.  In essence, any
dynamic scope in Perl 6 is allowed to do IO redirection much like
a Unix shell does with its subprocesses, albeit with a different
syntax:

  {
      my $*OUT will leave *.close = open $newfile, :w;
      say "Written to $newfile";
  }
  # stdout reverts to outer scope's definition, and closed the file

In short:

              default handle
    routine   for sub form    purpose
    =======   ===========     =======
    print     $*OUT           string-based writing
    say       $*OUT           string-based writing
    get       $*ARGFILES      read a line (Str)
    lines     $*ARGFILES      read all lines (Str)
    words     $*ARGFILES      read all words (Str)
    read                      binary reading (Buf)
    write                     binary writing (Buf)

=head1 A changing world

The world in which we expect Perl 6 to operate, has changed significantly in
the past 10 years.  From an I/O point of view, there are no operating systems
that are completely different from the other ones anymore.  On the operating
systems we can expect Perl 6 to run in the foreseeable future, we can see that
B<forward> slashes are accepted as directory separators on all systems.
Windows still supports the concept of a volume (e.g. B<C:>), but accepts
forward slashes as directory separators (even though it returns backslashes
when interrogated).  And network mounts are recognizable by their C<//> at
the beginning.

So from a developer point of view, doing portable I/O to files on a local
(or even remote) filesystem, can become much simpler.  So, in Perl 6, we take
the simplest approach:

  /foo/bar         Unix-like
  C:/foo/bar       On Windows systems
  //foo/bar        Network mount

That's all you need to think about when doing I/O to file systems.

To make things visually easier, and internally as well, Perl 6 makes a
difference between path names that are directories, and path names that
aren't.  Directories are always represented with a trailing slash (C<"/">),
others will never have a trailing slash.

=head1 Path Names and the .IO coercer

Path names are just strings (C<Str>).  Methods that return path names, will
just return strings.  As soon as you need to do manipulation on the path name
(e.g. to find out its C<basename> or C<extension>), you can create an
object out of the string by applying the C<.IO> coercer:

  my $io = '/foo/bar/info.txt'.IO;
  say $io.basename;   # info
  say $io.extension;  # txt
  say $io.parent;     # /foo/bar/

Note that the C<open> method on the object returned by the C<.IO> coercer:

  my $handle = $newfile.IO.open(:w);

is just really syntactic sugar for:

  my $handle = open $newfile, :w;

Depending on the existence and the type of the given string, the C<.IO>
coercer returns one of 4 object types:

  IO::File      # a regular file
  IO::Dir       # a directory
  IO::Local     # something else that exists
  IOU           # not recognized as something that exists

All these classes are consumers of the C<IO::Pathy> role, which provided all
of the methods that have to do with paths (such as C<.basename>).

=head1 $*CWD and chdir()

The dynamic variable $*CWD is an C<IO::Dir> object representing the current
working directory.  It is normally set with the C<chdir()> function, which will
check whether the specified path exists as a directory and is accessible
(C<-x>).

  chdir($dir);  # sets $*CWD of scope, usually PROCESS::<$CWD>

The C<chdir()> function returns a C<X::IO::Chdir> Failure if the path does
not exist, or is not a directory, or is not accessible.  Otherwise
returns a newly created C<IO::Dir> object (which will be C<True>).

Please note that the path in C<$*CWD> does not have any bearing on what the
underlying operating system's concept of a "current directory".  It is simply
the path that will prepended before any implicit or explicit relative paths,
and the default path that will be used when executing a sub-process.

To be changing C<$*CWD> just for a given scope, you can use C<indir()>:

  indir $dir, {
      ... your code in $dir ...
  };
  ... your code in original $*CWD again ...

or you can use C<chdir()> with a temporary C<$*CWD>:

  {
      temp $*CWD = chdir($dir);
      ... your code in $dir ...
  }
  ... your code in original $*CWD again ...

=head1 $*TMPDIR and tmpdir()

The dynamic variable C<$*TMPDIR> is an C<IO::Dir> object which points to the
system's directory for temporary files.  It can be set with the C<tmpdir()>
function which will check whether the specified path exists as a directory and
has complete access (C<+rwx>).

  tmpdir($dir);  # sets $*TMPDIR of scope, usually PROCESS::<$TMPDIR>

To set a locally scoped version of C<$*TMPDIR>, you can use C<tmpdir()> with
a temporary C<$*TMPDIR>:

  {
      temp $*TMPDIR = $tmpdir($dir);
      ... your code with $*TMPDIR being $dir ...
  }
  ... your code in original $*TMPDIR again ...

It will return a newly created C<IO::Dir> object (which is C<True>) or an
appropriate C<Failure>.

The initialization of C<$*TMPDIR> at startup is set depending on the OS you're
on.

=head1 $*HOME and homedir()

The dynamic variable C<$*HOME> is an C<IO::Dir> object which points to the
user's home directory.  It can be set with the C<homedir()> function
which will check whether the specified path exists as a directory and is
completely accessible (C<+rwx>).

  homedir($dir);  # sets $*HOME of scope, usually PROCESS::<$HOME>

To set a locally scoped version of C<$*HOME>, you can use C<homedir()> with a
temporary C<$*HOME>:

  {
      temp $*HOME = homedir($dir);
      ... your code with $*HOME being $dir ...
  }
  ... your code in original $*HOME again ...

It will return a newly created C<IO::Dir> object (which is C<True>) or an
appropriate C<Failure>.

The initialization of C<$*HOME> at startup is set depending on the OS you're on.

=head1 Functions, Roles and Classes

The functions and classes that define most of the functionality for IO are
more thoroughly defined in S32-setting-library/IO.pod.  The main functions
used are listed in S29 with references to S32-setting-library/IO.pod.
An overview:

=head2 Functions

  print(@text)                   # print text on $*OUT
  say(@text)                     # print text + newline on $*OUT
  note(@text)                    # print text + newline on $*ERR
  dd($a,$b,$c)                   # tiny data dumper on $*ERR
  $line = prompt($message)       # print message on $*OUT, obtain next line

  $handle = open($path)          # open a file, return IO::Handle
  $handle = pipe($command)       # open a pipe, return IO::Pipe
  $handle = socket($host,$port)  # connect to host:port, return IO::Socket

  @locals = dir                  # paths (as IO::Pathy) in $*CWD
  @locals = dir('/foo')          # paths (as IO::Pathy) in /foo
  @strs = dir(:Str)              # paths (as Str) in $*CWD

  $contents = slurp('/foo/bar')  # read all from /foo/bar
  $contents = slurp-rest($h)     # read all that's left of an opened filehandle

  spurt($handle,$contents)       # write $contents to $handle
  spurt('/foo/bar',$contents)    # write $contents to /foo/bar

  mkdir('/foo')                  # create a directory
  rmdir('/foo')                  # remove a directory
  mkpath('/foo/voodo')           # create directory and parents as appropriate

  chdir('foo')                   # set $*CWD
  temp $*CWD = chdir('/foo')     # set $*CWD for the current scope

  indir('/foo', { ... })         # execute code with temporary $*CWD

  tmpdir('/foo')                 # set $*TMPDIR
  temp $*TMPDIR = tmpdir('/foo') # set $*TMPDIR for the current scope

  homedir('/me')                 # set $*HOME
  temp $*HOME = homedir('/me')   # set $*HOME for the current scope

  copy('/foo/bar','/foo/baz')    # copy a file
  rename('/foo/bar','/foo/baz')  # rename (move) a file on same physical storage
  move('/foo/bar','/foo/baz')    # move (rename) a file to other storage
  unlink(@files)                 # remove one or more files
  chmod($permission,*@files)     # change permissions of one or more files

  link($target,$source)          # create a hard-link to a file
  symlink($target,$source)       # create a symbolic link to a file

=head2 IO::Pathy role

These classes consume the C<IO::Pathy> role:

  IO::Handle    # an opened regular file
  IO::File      # a regular file
  IO::Dir       # a directory
  IO::Local     # something else that exists (locally)
  IOU           # not recognized as something that exists

The easiest way to create an object that does the C<IO::Pathy> role, is to
use the C<.IO> coercer.  It takes an optional C<:CWD> parameter to indicate
what the current directory is supposed to be (for relative paths, defaults to
C<$*CWD>).

  my $io = $filename.IO;               # current directory
  my $io = $filename.IO(:CWD($*CWD));  # same

The following file test methods are provided by the IO::Pathy role, or are
overridden by a class (e.g. C<.e> is overridden to return C<True> for all but
the C<IOU> class):

  r          is readable by effective uid/gid
  w          is writable by effective uid/gid
  rw         is readable and writable by effective uid/gid
  x          is executable by effective uid/gid
  rx         is readable and executable by effective uid/gid
  wx         is writable and executable by effective uid/gid
  rwx        is readable, writable and executable by effective uid/gid
  o          is owned by effective uid

  R          is readable by real uid/gid
  W          is writable by real uid/gid
  RW         is readable and writable by real uid/gid
  X          is executable by real uid/gid
  RX         is readable and executable by real uid/gid
  WX         is writable and executable by real uid/gid
  RWX        is readable, writable and executable by real uid/gid
  O          is owned by real uid

  e          exists
  s          size of the $!path of $io in bytes
  z          has zero size (an empty file)

  f          is a plain file  (also ~~ IO::File)
  d          is a directory   (also ~~ IO::Dir)
  l          is a symbolic link
  L          path of symbolic link (readlink)
  b          is a block special file
  c          is a character special file

  u          has setuid bit set
  g          has setgid bit set
  k          has sticky bit set

A typical use case would be:

  if $io.f && $io.rwx && $io.s -> $size {
      say "plain file with rwx of $size bytes";
  }

which you can also smart match:

  given $io {
      when :f :rwx {
          say "plain file with rwx of $_.s() bytes";
      }
  }

Please note that another of determining whether an object, that consumes the
IO::Pathy role, is a regular file or a directory, is by smartmatching the
object with the class:

  given $io {
      when IO::File {
          say "$io is a regular file";
      }
      when IO::Dir {
          say "$io is a directory";
      }
      when IOU {
          say "doesn't exist";
      }
  }

Methods that do not access the file system and purely operate on the
given path (in alphabetical order):

  abspath        the absolute, canonical path
  basename       the basename of the path
  child          append basename to path, return new object for that
  dirname        the directory part of the absolute path
  extension      the extension of the path
  parent         remove last portion of path, return new object for that
  pred           previous logical path, return new object for that
  relpath        the relative path against $*CWD
  succ           next logical path, return new object for that
  volume         the volume of the path (if any)

Methods that access the file system to operate on the given path (in
alphabetical order).  May only make sense on certain consumers of the IO::Pathy
role:

  accessed       last access time (if available)
  changed        last (metadata) changed time
  chdir          change $*CWD
  chmod          change attributes
  copy           create a copy
  dir            files in path
  lines          contents as lines
  mkdir          create directory
  modified       last modified time
  move           move (rename) to other storage
  open           attempt to open as file
  rename         rename (move) to other name
  resolve        follow symlinks to the real path, return new object for that
  rmdir          remove directory if empty directory
  slurp          obtain the contents
  spurt          set the contents
  unlink         remove as local entity
  words          contents of file as words

=head2 PIO role

These classes consume the C<PIO> (B<P>erl6 B<IO>)  role:

  IO::Dup       # handle from a fileno(), such as $*IN, $*OUT, $*ERR
  IO::Handle    # an opened regular file
  IO::Pipe      # a pipe
  IO::Socket    # a socket

An object that consumes the PIO role, is generally created by calling the
associated function (such as C<open>, C<pipe> or C<socket>)>, or is accessible
by already defined dynamic variables such as C<$*IN>.

These are the methods provided by the PIO role (an alphabetical order):

  close          close file handle, flush buffers
  encoding       set/return encoding
  eof            file pointer reached end of information
  fileno         file descriptor (usually a native integer)
  flush          flush buffers
  get            get next line
  getc           get next character
  ins            number of lines read
  lines          return rest of contents as lines
  opened         is it not closed?
  p              the handle is a pipe
  print          write characters
  read           read bytes
  S              is a socket
  say            write characters + newline
  seek           move pointer to given position
  slurp-rest     return rest of contents
  spurt          write / append contents
  t              is it a TTY (is a person looking?)
  tell           return position of pointer
  words          return rest of contents as words
  write          write bytes

=head2 IO::File

  class IO::File does IO does IO::Pathy

An object indicating an existing, normal (C<-f>) file.  Usually created as
one of the objects returned by a C<dir()>, or the C<.IO> coercer.

=head2 IO::Dir

  class IO::Dir does IO does IO::Pathy

An object indicating an existing directory (C<-d>).  Usually created as
one of the objects returned by a C<dir()>, C<chdir()>, C<tmpdir()>,
C<homedir()> or the C<.IO> coercer.

=head2 IO::Local

  class IO::Local does IO does IO::Pathy

An object indicating an existing directory entry (C<-l>, C<-L>, C<-b> or
C<-c>).  Usually created as one of the objects returned by a C<dir()> or
the C<.IO> coercer.

=head2 IOU

  class IOU does IO does IO::Pathy

An object indicating an B<non>-existing directory entry (C<!-e>).  Usually
created by the C<.IO> coercer.

=head2 IO::Dup

  class IO::Dup does IO does PIO

An object encapsulating an operating system's filehandle, indicated by its
C<fileno>.  Usually pre-created at startup and found in C<$*IN>, C<$*OUT> and
C<$*ERR>.

=head2 IO::Handle

  class IO::Handle does IO does PIO does IO:Pathy

An object for an opened file, usually created with C<open()>.

=head2 IO::Pipe

  class IO::Pipe does IO does PIO

An object representing an opened pipe, usually created with C<pipe()>.

=head2 IO::Socket

  class IO::Socket does IO does PIO

An object representing an opened socket, usually created with C<socket()>.

=head1 AUTHORS

    Largely, the authors of the related Perl 5 docs.
    Larry Wall <larry@wall.org>
    Mark Stosberg <mark@summersault.com>
    Tim Nelson <wayland@wayland.id.au>
    Daniel Ruoso <daniel@ruoso.com>
    Elizabeth Mattijsen <liz@dijkmat.nl>

=for vim:set expandtab sw=4:
